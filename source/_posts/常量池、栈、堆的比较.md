title: 常量池、栈、堆的比较
author: superman
tags: []
categories: []
date: 2018-03-03 14:34:00
---
看到一篇文章写的很清晰,源地址:

https://www.cnblogs.com/Eason-S/p/5658230.html


JAVA中，有六个不同的地方可以存储数据：

**1.寄存器**：最快的存储区，位于不同于其他存储区的地方——处理器内部。寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。

**2\. 栈**：存放基本类型的变量数据和对象的引用。位于通用RAM中，但通过它的“堆栈指针”可以从处理器哪里获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成 相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活性。

**3\. 堆**：一种通用性的内存池（也存在于RAM中），用于存放所以的JAVA对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代码。用堆进行存储分配比用堆栈进行存储存储需要更多的时间。  

**4\. 静态域**：存放静态成员（static定义的） 。

**5\. 常量池**：存放字符串常量和基本类型常量（public static final）。 常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。

**6\. 非RAM存储**：硬盘等永久存储空间。如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。 

这里我们主要关心栈，堆和常量池，对于栈和常量池中的对象可以共享，对于堆中的对象不可以共享。

栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失。堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。    

**(1)对于字符串**：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。

例如：

```
String s1 = "china";
String s2 = "china";
String s3 = "china";
String ss1 = new String("china");
String ss2 = new String("china");
String ss3 = new String("china");
```

![](https://images2015.cnblogs.com/blog/922762/201607/922762-20160710174112202-1015226419.png)

对于通过new产生一个字符串（假设为”china”）时，会先去常量池中查找是否已经有了”china”对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此”china”对象的拷贝对象。

这也就是有道面试题：String s = new String(“xyz”);产生几个对象？答：一个或两个，如果常量池中原来没有”xyz”,就是两个。

**(2)对于基础类型的变量和常量**：变量和引用存储在栈中，常量存储在常量池中。

例如：

```
int i1 = 9;
int i2 = 9;
int i3 = 9; 
public static final int INT1 = 9;
public static final int INT2 = 9;
public static final int INT3 = 9;
```

![](https://images2015.cnblogs.com/blog/922762/201607/922762-20160710174141764-2118970512.png)

对于成员变量和局部变量：成员变量就是方法外部，类的内部定义的变量；局部变量就是方法或语句块内部定义的变量。局部变量必须初始化。

形式参数是局部变量，局部变量的数据存在于栈内存中。栈内存中的局部变量随着方法的消失而消失。

成员变量存储在堆中的对象里面，由垃圾回收器负责回收。

下面给出一个实例：

```
class BirthDate {
    private int day;
    private int month;
    private int year;    
    public BirthDate(int d, int m, int y) {
        day = d; 
        month = m; 
        year = y;
    }
    省略get,set方法………
}

public class Test{
    public static void main(String args[]){
        int date = 9;
        Test test = new Test();      
        test.change(date); 
        BirthDate d1= new BirthDate(7,7,1970);       
    }  

    public void change(int i){
     i = 1234;
    }
}
```

![](https://images2015.cnblogs.com/blog/922762/201607/922762-20160710174216217-1171188913.png)

对于以上这段代码，date为局部变量，i,d,m,y都是形参为局部变量，day，month，year为成员变量。下面分析一下代码执行时候的变化：

1\. main方法开始执行：int date = 9;

date局部变量，基础类型，引用和值都存在栈中。

2\. Test test = new Test();

test为对象引用，存在栈中，对象(new Test())存在堆中。

3\. test.change(date);

i为局部变量，引用和值存在栈中。当方法change执行完成后，i就会从栈中消失。

4\. BirthDate d1= new BirthDate(7,7,1970);  

d1为对象引用，存在栈中，对象(new BirthDate())存在堆中，其中d，m，y为局部变量存储在栈中，且它们的类型为基础类型，因此它们的数据也存储在栈中。day,month,year为成员变量，它们存储在堆中(new BirthDate()里面)。当BirthDate构造方法执行完之后，d,m,y将从栈中消失。

5.main方法执行完之后，date变量，test，d1引用将从栈中消失，new Test(),new BirthDate()将等待垃圾回收。

参考：
<http://www.iteye.com/topic/634530>
<http://www.cnblogs.com/xiohao/p/4296088.html>
《深入理解java虚拟机———jvm高级特性与最佳实践》
