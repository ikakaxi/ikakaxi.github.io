<!DOCTYPE html>




<html class="theme-next mist" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="用来记录一些技术文章">
<meta property="og:type" content="website">
<meta property="og:title" content="我的技术小屋">
<meta property="og:url" content="https://ikakaxi.github.io/page/8/index.html">
<meta property="og:site_name" content="我的技术小屋">
<meta property="og:description" content="用来记录一些技术文章">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的技术小屋">
<meta name="twitter:description" content="用来记录一些技术文章">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ikakaxi.github.io/page/8/"/>





  <title>我的技术小屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我的技术小屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">爱编码,爱电子产品,爱科幻</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ikakaxi.github.io/2018/02/07/Android-Studio多工程引用同一个library项目配置方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的技术小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/Android-Studio多工程引用同一个library项目配置方法/" itemprop="url">Android Studio多工程引用同一个library项目配置方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T22:25:04+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/Android-Studio多工程引用同一个library项目配置方法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/Android-Studio多工程引用同一个library项目配置方法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用Android Studio 开发中，如遇到多个项目引用同一个library（源码）的情况时，会遇到在每个项目中都要有一套library的代码，对还在开发和维护中的library需要频繁的修改，这对同步就很麻烦了，下面提出以下方法供选择。当然最后会给出最合理的解决办法。</p>
<p><strong>第一种</strong>方法是对library向每个引用的项目建立软连接。这样修改就会对每个引用同步修改.这种方法就是看起来会很臃肿，如果要引用多个library就很痛苦。</p>
<p><strong>第二种</strong>就是maven 仓库的方式，将所有的library都上传到maven仓库，然后在各个工程中进行引用，当然这种是对稳定的library来说是最好的一种方式，但对于library需要开发和修改的就不太适合了。</p>
<p><strong>第三种</strong>就是将所有的library作为一个工程使用，然后将所有的library都放入此工程中，然后在其他引用library的工程中，引入新建的工程，这样看起来和eclipse 引用library的结构就很像了，且可以放入多个library都不影响。下面就来看看这种解决方法，该如何实现。</p>
<p>首先新建一个工程，注意是工程，不是Stuio里面的Module，起一个容易理解的工程名称CommonLibrary。</p>
<p>将需添加的library添加进CommonLibrary中，记得每个library也是需要有build.gradle文件的，且配置项正确。<br>在需要引用的的工程中，需要在settings.gradle文件中添加引用代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:CommonLibrary&apos;</span><br><span class="line">project (&apos;:CommonLibrary&apos;).projectDir = new File(&apos;../CommonLibrary/&apos;)</span><br><span class="line">include &apos;:CommonLibrary:CommonsA&apos;</span><br><span class="line">include &apos;:CommonLibrary:CommonsB&apos;</span><br></pre></td></tr></table></figure></p>
<p>其中CommonsA为项目要使用的公共library名称然后在我们项目实际的model中修改build.gradle<br>文件，需要在dependencies<br>中添加下面的代码。CommonsA和CommonsB都是要要引用的项目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile project (&apos;:CommonLibrary:CommonsA&apos;)</span><br><span class="line">compile project (&apos;:CommonLibrary:CommonsB&apos;)</span><br></pre></td></tr></table></figure>
<p>至此多个工程引用同一个lib的方法就基本完成，配置玩后sync下，然后build，看是否成功。</p>
<p>转载:<a href="http://wxtlife.com/2015/12/17/Android-studio-quote-same-lib/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://wxtlife.com/2015/12/17/Android-studio-quote-same-lib/?utm_source=tuicool&amp;utm_medium=referral</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ikakaxi.github.io/2018/02/07/Android中不同Context的使用方法和适用范围/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的技术小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/Android中不同Context的使用方法和适用范围/" itemprop="url">Android中不同Context的使用方法和适用范围</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T22:14:54+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/Android中不同Context的使用方法和适用范围/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/Android中不同Context的使用方法和适用范围/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###1、Context概念<br>其实一直想写一篇关于Context的文章，但是又怕技术不如而误人子弟，于是参考了些资料，今天准备整理下写出来，如有不足，请指出，参考资料会在醒目地方标明。<br>Context，相信不管是第一天开发<a href="http://lib.csdn.net/base/android" target="_blank" rel="noopener">Android</a>，还是开发Android的各种老鸟，对于Context的使用一定不陌生~~你在加载资源、启动一个新的Activity、获取系统服务、获取内部文件（夹）路径、创建View操作时等都需要Context的参与，可见Context的常见性。大家可能会问到底什么是Context，Context字面意思上下文，或者叫做场景，也就是用户与<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="noopener">操作系统</a>操作的一个过程，比如你打电话，场景包括电话程序对应的界面，以及隐藏在背后的数据；<br> 但是在程序的角度Context又是什么呢？在程序的角度，我们可以有比较权威的答案，Context是个抽象类，我们可以直接通过看其类结构来说明答案：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545982-6001ade83c752537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到Activity、Service、Application都是Context的子类；<br>也就是说，Android系统的角度来理解：Context是一个场景，代表与操作系统的交互的一种过程。从程序的角度上来理解：Context是个抽象类，而Activity、Service、Application等都是该类的一个实现。<br>在仔细看一下上图：Activity、Service、Application都是继承自ContextWrapper，而ContextWrapper内部会包含一个base context，由这个base context去实现了绝大多数的方法。<br>先扯这么多，有能力了会从别的角度去审视Context，加油~</p>
<p>###2、Context与ApplicationContext<br>看了标题，千万不要被误解，ApplicationContext并没有这个类，其实更应该叫做：Activity与Application在作为Context时的区别。嗯，的确是这样的，大家在需要Context的时候，如果是在Activity中，大多直接传个this，当在匿名内部类的时候，因为this不能用，需要写XXXActivity.this，很多哥们会偷懒，直接就来个getApplicationContext。那么大家有没有想过，XXXActivity.this和getApplicationContext的区别呢？<br>XXXActivity和getApplicationContext返回的肯定不是一个对象，一个是当前Activity的实例，一个是项目的Application的实例。既然区别这么明显，那么各自的使用场景肯定不同，乱使用可能会带来一些问题。<br>下面开始介绍在使用Context时，需要注意的问题。</p>
<p>###3、引用的保持</p>
<p>大家在编写一些类时，例如工具类，可能会编写成单例的方式，这些工具类大多需要去访问资源，也就说需要Context的参与。<br>在这样的情况下，就需要注意Context的引用问题。<br>例如以下的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.mooc.shader.roundimageview;  </span><br><span class="line">  </span><br><span class="line">import android.content.Context;  </span><br><span class="line">  </span><br><span class="line">public class CustomManager  </span><br><span class="line">&#123;  </span><br><span class="line">    private static CustomManager sInstance;  </span><br><span class="line">    private Context mContext;  </span><br><span class="line">  </span><br><span class="line">    private CustomManager(Context context)  </span><br><span class="line">    &#123;  </span><br><span class="line">        this.mContext = context;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static synchronized CustomManager getInstance(Context context)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (sInstance == null)  </span><br><span class="line">        &#123;  </span><br><span class="line">            sInstance = new CustomManager(context);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return sInstance;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    //some methods   </span><br><span class="line">    private void someOtherMethodNeedContext()  </span><br><span class="line">    &#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于上述的单例，大家应该都不陌生（请别计较getInstance的效率问题），内部保持了一个Context的引用；<br>这么写是没有问题的，问题在于，这个Context哪来的我们不能确定，很大的可能性，你在某个Activity里面为了方便，直接传了个this;这样问题就来了，我们的这个类中的sInstance是一个static且强引用的，在其内部引用了一个Activity作为Context，也就是说，我们的这个Activity只要我们的项目活着，就没有办法进行内存回收。而我们的Activity的生命周期肯定没这么长，所以造成了内存泄漏。<br>那么，我们如何才能避免这样的问题呢？<br>有人会说，我们可以软引用，嗯，软引用，假如被回收了，你不怕NullPointException么。<br>把上述代码做下修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized CustomManager getInstance(Context context)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (sInstance == null)  </span><br><span class="line">        &#123;  </span><br><span class="line">            sInstance = new CustomManager(context.getApplicationContext());  </span><br><span class="line">        &#125;  </span><br><span class="line">        return sInstance;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，我们就解决了内存泄漏的问题，因为我们引用的是一个ApplicationContext，它的生命周期和我们的单例对象一致。<br>这样的话，可能有人会说，早说嘛，那我们以后都这么用不就行了，很遗憾的说，不行。上面我们已经说过，Context和Application Context的区别是很大的，也就是说，他们的应用场景（你也可以认为是能力）是不同的，并非所有Activity为Context的场景，Application Context都能搞定。<br>下面就开始介绍各种Context的应用场景。</p>
<p>###4、Context的应用场景</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545982-1582935f29bf28c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>大家注意看到有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释：<br>数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐。<br>数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。<br>数字3：在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）<br>注：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。</p>
<p>好了，这里我们看下表格，重点看Activity和Application，可以看到，和UI相关的方法基本都不建议或者不可使用Application，并且，前三个操作基本不可能在Application中出现。实际上，只要把握住一点，凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</p>
<p>###5、总结<br>好了，到此，Context的分析基本完成了，希望大家在以后的使用过程中，能够稍微考虑下，这里使用Activity合适吗？会不会造成内存泄漏？这里传入Application work吗？<br>由于参考内容过多，本文改为译文咯~~</p>
<p>转载:<a href="http://blog.csdn.net/lmj623565791/article/details/40481055" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/40481055</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ikakaxi.github.io/2018/02/07/The-APK-file-does-not-exist-on-disk的解决办法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的技术小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/The-APK-file-does-not-exist-on-disk的解决办法/" itemprop="url">The APK file does not exist on disk的解决办法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T22:14:02+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/The-APK-file-does-not-exist-on-disk的解决办法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/The-APK-file-does-not-exist-on-disk的解决办法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在android studio编译apk的时候,经常会出现这个错误,解决这个问题的方法很简单,点击刷新按钮即可解决<br><img src="http://upload-images.jianshu.io/upload_images/545982-5b3c6c5b4a263aa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ikakaxi.github.io/2018/02/07/Android性能优化之常见的内存泄漏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的技术小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/Android性能优化之常见的内存泄漏/" itemprop="url">Android性能优化之常见的内存泄漏</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T22:13:30+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/Android性能优化之常见的内存泄漏/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/Android性能优化之常见的内存泄漏/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####前言<br>对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。</p>
<p>最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：</p>
<ol>
<li><a href="http://bugly.qq.com/blog/?p=832" target="_blank" rel="noopener">内存泄露从入门到精通三部曲之基础知识篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=872" target="_blank" rel="noopener">内存泄露从入门到精通三部曲之排查方法篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=884" target="_blank" rel="noopener">内存泄露从入门到精通三部曲之常见原因与用户实践</a></li>
</ol>
<p>Realm同样给出了性能优化文章：</p>
<p><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/" target="_blank" rel="noopener">10条提升Android性能的建议</a></p>
<p>####内存泄漏</p>
<p>#####为什么会产生内存泄漏？<br>当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>
<p>#####内存泄漏对程序的影响？<br>内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。</p>
<p>####Android中常见的内存泄漏汇总</p>
<p>#####单例造成的内存泄漏<br>单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏，由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。<br>如下这个典例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AppManager &#123;</span><br><span class="line">    private static AppManager instance;</span><br><span class="line">    private Context context;</span><br><span class="line">    private AppManager(Context context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    public static AppManager getInstance(Context             context) &#123;</span><br><span class="line">        if (instance != null) &#123;</span><br><span class="line">            instance = new AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要：</p>
<ol>
<li>传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长</li>
<li>传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。</li>
</ol>
<p>所以正确的单例应该修改为下面这种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AppManager &#123;</span><br><span class="line">    private static AppManager instance;</span><br><span class="line">    private Context context;</span><br><span class="line">    private AppManager(Context context) &#123;</span><br><span class="line">        this.context = context.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    public static AppManager getInstance(Context context) &#123;</span><br><span class="line">        if (instance != null) &#123;</span><br><span class="line">            instance = new AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样不管传入什么Context最终将使用Application的Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏</p>
<p>#####非静态内部类创建静态实例造成的内存泄漏<br>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private static TestResource mResource = null;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        if(mResource == null)&#123;</span><br><span class="line">            mResource = new TestResource();</span><br><span class="line">        &#125;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">    class TestResource &#123;</span><br><span class="line">    //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请使用ApplicationContext</p>
<p>#####Handler造成的内存泄漏<br>Handler的使用造成的内存泄漏问题应该说最为常见了，平时在处理网络任务或者封装一些请求回调等api都应该会借助Handler来处理，对于Handler的使用代码编写一不规范即有可能造成内存泄漏，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private Handler mHandler = new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">        //...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line">    private void loadData()&#123;</span><br><span class="line">        //...request</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种创建Handler的方式会造成内存泄漏，由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏，所以另外一种做法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private MyHandler mHandler = new MyHandler(this);</span><br><span class="line">    private TextView mTextView ;</span><br><span class="line">    private static class MyHandler extends Handler &#123;</span><br><span class="line">        private WeakReference&lt;Context&gt; reference;</span><br><span class="line">        public MyHandler(Context context) &#123;</span><br><span class="line">        reference = new WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            MainActivity activity = (MainActivity) reference.get();</span><br><span class="line">            if(activity != null)&#123;</span><br><span class="line">            activity.mTextView.setText(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void loadData() &#123;</span><br><span class="line">        //...request</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>简书作者注:</strong><br>非static的inner class里面都会有一个this$0的字段保存它的父对象。在Java中，非静态(匿名)内部类会默认隐性引用外部类对象。而静态内部类不会引用外部类对象。一个编译后的inner class 很可能是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class parent$inner &#123;</span><br><span class="line">    synthetic parent this$0;</span><br><span class="line">    parent$inner(parent this$0) &#123;</span><br><span class="line">        this.this$0 = this$0;</span><br><span class="line">        this$0.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息，更准确的做法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private MyHandler mHandler = new MyHandler(this);</span><br><span class="line">    private TextView mTextView ;</span><br><span class="line">    private static class MyHandler extends Handler &#123;</span><br><span class="line">        private WeakReference&lt;Context&gt; reference;</span><br><span class="line">        public MyHandler(Context context) &#123;</span><br><span class="line">        reference = new WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            MainActivity activity = (MainActivity) reference.get();</span><br><span class="line">            if(activity != null)&#123;</span><br><span class="line">            activity.mTextView.setText(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void loadData() &#123;</span><br><span class="line">        //...request</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        mHandler.removeCallbacksAndMessages(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages();来移除指定的Runnable和Message。</p>
<p>#####线程造成的内存泄漏<br>对于线程造成的内存泄漏，也是平时比较常见的，异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成，那么将导致Activity的内存资源无法回收，造成内存泄漏。正确的做法还是使用静态内部类的方式，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static class MyAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; &#123;</span><br><span class="line">    private WeakReference&lt;Context&gt; weakReference;</span><br><span class="line"></span><br><span class="line">    public MyAsyncTask(Context context) &#123;</span><br><span class="line">        weakReference = new WeakReference&lt;&gt;(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Void doInBackground(Void... params) &#123;</span><br><span class="line">        SystemClock.sleep(10000);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onPostExecute(Void aVoid) &#123;</span><br><span class="line">        super.onPostExecute(aVoid);</span><br><span class="line">        MainActivity activity = (MainActivity) weakReference.get();</span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">        //...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static class MyRunnable implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        SystemClock.sleep(10000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//——————</span><br><span class="line">new Thread(new MyRunnable()).start();</span><br><span class="line">new MyAsyncTask(this).execute();</span><br></pre></td></tr></table></figure></p>
<p>这样就避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源。</p>
<p>#####资源未关闭造成的内存泄漏<br>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
<p>#####一些建议</p>
<ol>
<li>对于生命周期比Activity长的对象如果需要应该使用ApplicationContext</li>
<li>对于需要在静态内部类中使用非静态外部成员变量（如：Context、View )，可以在静态内部类中使用弱引用来引用外部类的变量来避免内存泄漏</li>
<li>对于不再需要使用的对象，显示的将其赋值为null，比如使用完Bitmap后先调用recycle()，再赋为null</li>
<li>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期</li>
<li><p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p>
<ol>
<li>将内部类改为静态内部类</li>
<li>静态内部类中使用弱引用来引用外部类的成员变量</li>
</ol>
</li>
<li><p>在涉及到Context时先考虑ApplicationContext，当然它并不是万能的，对于有些地方则必须使用Activity的Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>
</li>
</ol>
<p><a href="http://img.blog.csdn.net/20151123144226349" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/545982-4081d50705e029f0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></a><br><strong>其中：</strong>NO1表示Application和Service可以启动一个Activity，不过需要创建一个新的task任务队列。而对于Dialog而言，只有在Activity中才能创建</p>
<p>转载:<a href="http://hanhailong.com/2015/12/27/Android性能优化之常见的内存泄漏" target="_blank" rel="noopener">http://hanhailong.com/2015/12/27/Android性能优化之常见的内存泄漏</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ikakaxi.github.io/2018/02/07/Android-基于Message的进程间通信-Messenger完全解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的技术小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/Android-基于Message的进程间通信-Messenger完全解析/" itemprop="url">Android 基于Message的进程间通信 Messenger完全解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T22:13:11+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/Android-基于Message的进程间通信-Messenger完全解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/Android-基于Message的进程间通信-Messenger完全解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、概述<br>说到<a href="http://lib.csdn.net/base/android" target="_blank" rel="noopener">Android</a>进程间通信，大家肯定能想到的是编写aidl文件，然后通过aapt生成的类方便的完成服务端，以及客户端代码的编写。如果你对这个过程不熟悉，可以查看<a href="http://blog.csdn.net/lmj623565791/article/details/38461079" target="_blank" rel="noopener">Android aidl Binder框架浅析</a>；<br>当然今天要说的通信方式肯定不是通过编写aidl文件的方式，那么有请今天的主角：Messenger。ok，这是什么样的一个类呢？我们看下注释</p>
<blockquote>
<p>This allows for the implementation of message-based communication across processes</p>
</blockquote>
<p>允许实现基于消息的进程间通信的方式。<br>那么，什么叫基于消息的进程间通信方式呢？看个图理解下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545982-f67afdc2b18be185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可以看到，我们可以在客户端发送一个Message给服务端，在服务端的handler中会接收到客户端的消息，然后进行对应的处理，处理完成后，再将结果等数据封装成Message，发送给客户端，客户端的handler中会接收到处理的结果。</p>
<p>这样的进程间通信是不是很爽呢？</p>
<ul>
<li>基于Message，相信大家都很熟悉</li>
<li>支持回调的方式，也就是服务端处理完成长任务可以和客户端交互</li>
<li>不需要编写aidl文件<br>此外，还支持，记录客户端对象的Messenger，然后可以实现一对多的通信；甚至作为一个转接处，任意两个进程都能通过服务端进行通信，这个后面再说。</li>
</ul>
<p>看到这，有没有一些的小激动，我们可以不写aidl文件，方便的实现进程间通信了，是不是又可以装一下了。哈，下面看个简单的例子。</p>
<p>二、通信实例<br>这个例子，通过两个apk演示，一个apk是Server端，一个是Client端；<br>（1） Server端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.messenger_server;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Handler;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.Message;</span><br><span class="line">import android.os.Messenger;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">public class MessengerService extends Service</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    private static final int MSG_SUM = 0x110;</span><br><span class="line"></span><br><span class="line">    //最好换成HandlerThread的形式</span><br><span class="line">    private Messenger mMessenger = new Messenger(new Handler()</span><br><span class="line">    &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msgfromClient)</span><br><span class="line">        &#123;</span><br><span class="line">            Message msgToClient = Message.obtain(msgfromClient);//返回给客户端的消息</span><br><span class="line">            switch (msgfromClient.what)</span><br><span class="line">            &#123;</span><br><span class="line">                //msg 客户端传来的消息</span><br><span class="line">                case MSG_SUM:</span><br><span class="line">                    msgToClient.what = MSG_SUM;</span><br><span class="line">                    try</span><br><span class="line">                    &#123;</span><br><span class="line">                        //模拟耗时</span><br><span class="line">                        Thread.sleep(2000);</span><br><span class="line">                        msgToClient.arg2 = msgfromClient.arg1 + msgfromClient.arg2;</span><br><span class="line">                        msgfromClient.replyTo.send(msgToClient);</span><br><span class="line">                    &#125; catch (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; catch (RemoteException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            super.handleMessage(msgfromClient);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent)</span><br><span class="line">    &#123;</span><br><span class="line">        return mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端就一个Service，可以看到代码相当的简单，只需要去声明一个Messenger对象，然后onBind方法返回mMessenger.getBinder()；</p>
<p>然后坐等客户端将消息发送到handleMessage想法，根据message.what去判断进行什么操作，然后做对应的操作，最终将结果通过 msgfromClient.replyTo.send(msgToClient);返回。</p>
<p>可以看到我们这里主要是取出客户端传来的两个数字，然后求和返回，这里我有意添加了sleep(2000)模拟耗时,注意在实际使用过程中，可以换成在独立开辟的线程中完成耗时操作，比如和HandlerThread结合使用。</p>
<p>#####注册文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">           android:name=&quot;.MessengerService&quot;</span><br><span class="line">           android:enabled=&quot;true&quot;</span><br><span class="line">           android:exported=&quot;true&quot;&gt;</span><br><span class="line">           &lt;intent-filter&gt;</span><br><span class="line">               &lt;action android:name=&quot;com.zhy.aidl.calc&quot;&gt;&lt;/action&gt;</span><br><span class="line">               &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">           &lt;/intent-filter&gt;</span><br><span class="line">       &lt;/service&gt;</span><br></pre></td></tr></table></figure></p>
<p>别忘了注册service，写完以后直接安装。<br>（二）客户端<br>Activity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.messenger_client;</span><br><span class="line"></span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.ServiceConnection;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.Handler;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.Message;</span><br><span class="line">import android.os.Messenger;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.Button;</span><br><span class="line">import android.widget.LinearLayout;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends AppCompatActivity</span><br><span class="line">&#123;</span><br><span class="line">    private static final String TAG = &quot;MainActivity&quot;;</span><br><span class="line">    private static final int MSG_SUM = 0x110;</span><br><span class="line"></span><br><span class="line">    private Button mBtnAdd;</span><br><span class="line">    private LinearLayout mLyContainer;</span><br><span class="line">    //显示连接状态</span><br><span class="line">    private TextView mTvState;</span><br><span class="line"></span><br><span class="line">    private Messenger mService;</span><br><span class="line">    private boolean isConn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Messenger mMessenger = new Messenger(new Handler()</span><br><span class="line">    &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msgFromServer)</span><br><span class="line">        &#123;</span><br><span class="line">            switch (msgFromServer.what)</span><br><span class="line">            &#123;</span><br><span class="line">                case MSG_SUM:</span><br><span class="line">                    TextView tv = (TextView) mLyContainer.findViewById(msgFromServer.arg1);</span><br><span class="line">                    tv.setText(tv.getText() + &quot;=&gt;&quot; + msgFromServer.arg2);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            super.handleMessage(msgFromServer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private ServiceConnection mConn = new ServiceConnection()</span><br><span class="line">    &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service)</span><br><span class="line">        &#123;</span><br><span class="line">            mService = new Messenger(service);</span><br><span class="line">            isConn = true;</span><br><span class="line">            mTvState.setText(&quot;connected!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name)</span><br><span class="line">        &#123;</span><br><span class="line">            mService = null;</span><br><span class="line">            isConn = false;</span><br><span class="line">            mTvState.setText(&quot;disconnected!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private int mA;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState)</span><br><span class="line">    &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        //开始绑定服务</span><br><span class="line">        bindServiceInvoked();</span><br><span class="line"></span><br><span class="line">        mTvState = (TextView) findViewById(R.id.id_tv_callback);</span><br><span class="line">        mBtnAdd = (Button) findViewById(R.id.id_btn_add);</span><br><span class="line">        mLyContainer = (LinearLayout) findViewById(R.id.id_ll_container);</span><br><span class="line"></span><br><span class="line">        mBtnAdd.setOnClickListener(new View.OnClickListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v)</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    int a = mA++;</span><br><span class="line">                    int b = (int) (Math.random() * 100);</span><br><span class="line"></span><br><span class="line">                    //创建一个tv,添加到LinearLayout中</span><br><span class="line">                    TextView tv = new TextView(MainActivity.this);</span><br><span class="line">                    tv.setText(a + &quot; + &quot; + b + &quot; = caculating ...&quot;);</span><br><span class="line">                    tv.setId(a);</span><br><span class="line">                    mLyContainer.addView(tv);</span><br><span class="line"></span><br><span class="line">                    Message msgFromClient = Message.obtain(null, MSG_SUM, a, b);</span><br><span class="line">                    msgFromClient.replyTo = mMessenger;</span><br><span class="line">                    if (isConn)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //往服务端发送消息</span><br><span class="line">                        mService.send(msgFromClient);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (RemoteException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void bindServiceInvoked()</span><br><span class="line">    &#123;</span><br><span class="line">        Intent intent = new Intent();</span><br><span class="line">        intent.setAction(&quot;com.zhy.aidl.calc&quot;);</span><br><span class="line">        bindService(intent, mConn, Context.BIND_AUTO_CREATE);</span><br><span class="line">        Log.e(TAG, &quot;bindService invoked !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy()</span><br><span class="line">    &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        unbindService(mConn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码也不复杂，首先bindService，然后在onServiceConnected中拿到回调的service（IBinder）对象，通过service对象去构造一个mService =new Messenger(service);然后就可以使用mService.send(msg)给服务端了。</p>
<p>我们消息的发送在Btn.onclick里面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Message msgFromClient = Message.obtain(null, MSG_SUM, a, b);</span><br><span class="line">msgFromClient.replyTo = mMessenger;</span><br><span class="line">if (isConn)</span><br><span class="line">&#123;</span><br><span class="line">    //往服务端发送消息</span><br><span class="line">    mService.send(msgFromClient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么服务端会收到消息，处理完成会将结果返回，传到Client端的mMessenger中的Handler的handleMessage方法中。</p>
<p>布局文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout android:id=&quot;@+id/id_ll_container&quot;</span><br><span class="line">              xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">              xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">              android:layout_width=&quot;match_parent&quot;</span><br><span class="line">              android:layout_height=&quot;match_parent&quot;</span><br><span class="line">              android:orientation=&quot;vertical&quot;</span><br><span class="line">              android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;</span><br><span class="line">              android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;</span><br><span class="line">              android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;</span><br><span class="line">              android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;</span><br><span class="line">              tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/id_tv_callback&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;Messenger Test!&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button android:id=&quot;@+id/id_btn_add&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;add&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545982-198183741f1ffa64?imageMogr2/auto-orient/strip" alt=""><br>可以看到，我们每点击一次按钮，就往服务器发送个消息，服务器拿到消息执行完成后，将结果返回。<br>整个通信的代码看起来还是相当的清爽的，那么大家有没有对其内部的原理有一丝的好奇呢？下面我们就来看下其内部是如何实现的。<br>对了，源码分析前，这里插一句，大家通过代码可以看到服务端往客户端传递数据是通过msg.replyTo这个对象的。那么服务端完全可以做到，使用一个List甚至Map去存储所有绑定的客户端的msg.replyTo对象，然后想给谁发消息都可以。甚至可以把A进程发来的消息，通过B进程的msg.replyTo发到B进程那里去。相关代码呢，可以参考官方的文档：<a href="http://developer.android.com/reference/android/app/Service.html" target="_blank" rel="noopener">service</a>，注意下拉找：Remote Messenger Service Sample。</p>
<p>三、源码分析<br>其实Messenger的内部实现的，实际上也是依赖于aidl文件实现的。<br>（一）首先我们看客户端向服务端通信<br>服务端<br>服务端的onBind是这么写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public IBinder onBind(Intent intent)</span><br><span class="line">    &#123;</span><br><span class="line">        return mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>那么点进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public IBinder getBinder() &#123;</span><br><span class="line">        return mTarget.asBinder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到返回的是mTarget.asBinder();</p>
<p>mTarget是哪来的呢？</p>
<p>别忘了我们前面去构造mMessenger对象的代码：new Messenger(new Handler())；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Messenger(Handler target) &#123;</span><br><span class="line">       mTarget = target.getIMessenger();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>原来是Handler返回的，我们继续跟进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final IMessenger getIMessenger() &#123;</span><br><span class="line">    synchronized (mQueue) &#123;</span><br><span class="line">        if (mMessenger != null) &#123;</span><br><span class="line">            return mMessenger;</span><br><span class="line">        &#125;</span><br><span class="line">        mMessenger = new MessengerImpl();</span><br><span class="line">        return mMessenger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private final class MessengerImpl extends IMessenger.Stub &#123;</span><br><span class="line">    public void send(Message msg) &#123;</span><br><span class="line">        msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">        Handler.this.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mTarget是一个MessengerImpl对象，那么asBinder实际上是返回this，也就是MessengerImpl对象；<br>这是个内部类，可以看到继承自IMessenger.Stub，然后实现了一个send方法，该方法就是将接收到的消息通过 Handler.this.sendMessage(msg);发送到handleMessage方法。<br>看到这，大家有没有想到什么，难道不觉得extends IMessenger.Stub这种写法异常的熟悉么？<br>我们传统写aidl文件，aapt给我们生成什么，生成IXXX.Stub类，然后我们服务端继承IXXX.Stub实现接口中的方法。<br>没错，其实这里内部其实也是依赖一个aidl生成的类，这个aidl位于：frameworks/base/core/<a href="http://lib.csdn.net/base/javase" target="_blank" rel="noopener">Java</a>/android/os/IMessenger.aidl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package android.os;  </span><br><span class="line"></span><br><span class="line">import android.os.Message;  </span><br><span class="line"></span><br><span class="line">/** @hide */  </span><br><span class="line">oneway interface IMessenger &#123;  </span><br><span class="line">    void send(in Message msg);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这，你应该明白了，Messenger并没有什么神奇之处，实际上，就是依赖该aidl文件生成的类，继承了IMessenger.Stub类，实现了send方法，send方法中参数会通过客户端传递过来，最终发送给handler进行处理。这里不理解，请详细看下<a href="http://blog.csdn.net/lmj623565791/article/details/38461079" target="_blank" rel="noopener">Android aidl Binder框架浅析</a>；</p>
<p><strong>客户端</strong><br>客户端首先通过onServiceConnected拿到sevice（Ibinder）对象，这里没什么特殊的，我们平时的写法也是这样的，只不过我们平时会这么写：</p>
<blockquote>
<p>IMessenger.Stub.asInterface(service)拿到接口对象进行调用；</p>
</blockquote>
<p>而，我们的代码中是<br>mService = new Messenger(service);<br>跟进去，你会发现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Messenger(IBinder target) &#123;</span><br><span class="line">        mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>soga，和我们平时的写法一模一样！<br>到这里就可以明白，客户端与服务端通信，实际上和我们平时的写法没有任何区别，通过编写aidl文件，服务端onBind利用Stub编写接口实现返回；客户端利用回调得到的IBinder对象，使用IMessenger.Stub.asInterface(target)拿到接口实例进行调用（内部实现，参考<a href="http://blog.csdn.net/lmj623565791/article/details/38461079" target="_blank" rel="noopener">Android aidl Binder框架浅析</a>）。<br>（2）服务端与客户端通信<br>那么，客户端与服务端通信的确没什么特殊的地方，我们完全也可以编写个类似的aidl文件实现；那么服务端是如何与客户端通信的呢？<br>还记得，客户端send方法发送的是一个Message，这个Message.replyTo指向的是一个mMessenger，我们在Activity中初始化的。<br>那么将消息发送到服务端，肯定是通过序列化与反序列化拿到Message对象，我们看下Message的反序列化的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Message</span><br><span class="line"></span><br><span class="line">private void readFromParcel(Parcel source) &#123;</span><br><span class="line">        what = source.readInt();</span><br><span class="line">        arg1 = source.readInt();</span><br><span class="line">        arg2 = source.readInt();</span><br><span class="line">        if (source.readInt() != 0) &#123;</span><br><span class="line">            obj = source.readParcelable(getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        when = source.readLong();</span><br><span class="line">        data = source.readBundle();</span><br><span class="line">        replyTo = Messenger.readMessengerOrNullFromParcel(source);</span><br><span class="line">        sendingUid = source.readInt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要看replyTo，调用的是Messenger.readMessengerOrNullFromParcel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Messenger readMessengerOrNullFromParcel(Parcel in) &#123;</span><br><span class="line">        IBinder b = in.readStrongBinder();</span><br><span class="line">        return b != null ? new Messenger(b) : null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void writeMessengerOrNullToParcel(Messenger messenger,</span><br><span class="line">            Parcel out) &#123;</span><br><span class="line">        out.writeStrongBinder(messenger != null ? messenger.mTarget.asBinder()</span><br><span class="line">                : null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的writeMessengerOrNullToParcel可以看到，它将客户端的messenger.mTarget.asBinder()对象进行了恢复，客户端的message.mTarget.asBinder()是什么？</p>
<p>客户端也是通过Handler创建的Messenger，于是asBinder返回的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public Messenger(Handler target) &#123;</span><br><span class="line">        mTarget = target.getIMessenger();</span><br><span class="line">    &#125;</span><br><span class="line"> final IMessenger getIMessenger() &#123;</span><br><span class="line">        synchronized (mQueue) &#123;</span><br><span class="line">            if (mMessenger != null) &#123;</span><br><span class="line">                return mMessenger;</span><br><span class="line">            &#125;</span><br><span class="line">            mMessenger = new MessengerImpl();</span><br><span class="line">            return mMessenger;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final class MessengerImpl extends IMessenger.Stub &#123;</span><br><span class="line">        public void send(Message msg) &#123;</span><br><span class="line">            msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">            Handler.this.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public IBinder getBinder() &#123;</span><br><span class="line">        return mTarget.asBinder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>那么asBinder，实际上就是MessengerImpl extends IMessenger.Stub中的asBinder了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#IMessenger.Stub</span><br><span class="line"></span><br><span class="line">@Override </span><br><span class="line">public android.os.IBinder asBinder()</span><br><span class="line">&#123;</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么其实返回的就是MessengerImpl对象自己。到这里可以看到message.mTarget.asBinder()其实返回的是客户端的MessengerImpl对象。</p>
<p>最终，发送给客户端的代码是这么写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msgfromClient.replyTo.send(msgToClient);</span><br><span class="line"></span><br><span class="line">public void send(Message message) throws RemoteException &#123;</span><br><span class="line">        mTarget.send(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个mTarget实际上就是对客户端的MessengerImpl对象的封装，那么send(message)（屏蔽了transact/onTransact的细节），这个message最终肯定传到客户端的handler的handleMessage方法中。</p>
<p>好了，到此我们的源码分析就结束了~~</p>
<p>总结下：</p>
<ul>
<li>客户端与服务端通信，利用的aidl文件，没什么特殊的</li>
<li>服务端与客户端通信，主要是在传输的消息上做了处理，让Messager.replyTo指向的客户端的Messenger,而Messenger又持有客户端的一个Binder对象（MessengerImpl）。服务端正是利用这个Binder对象做的与客户端的通信。</li>
</ul>
<p>可以考虑自己编写aidl文件，实现下服务端对客户端的回调。</p>
<p>转载:<a href="http://blog.csdn.net/lmj623565791/article/details/47017485" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/47017485</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ikakaxi.github.io/2018/02/07/远程Service中的DeathRecipient和RemoteCallbackList-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的技术小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/远程Service中的DeathRecipient和RemoteCallbackList-1/" itemprop="url">远程Service中的DeathRecipient和RemoteCallbackList</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T22:12:41+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/远程Service中的DeathRecipient和RemoteCallbackList-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/远程Service中的DeathRecipient和RemoteCallbackList-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>DeathRecipient:用这个的原因是担心客户端异常销毁时,服务器收不到消息,造成资源浪费等异常<br>RemoteCallbackList:同样的,我们在服务端通知客户端消息的时候,也担心 服务端会异常销毁,导致客户端收不到消息</p>
<p>这两个类的使用demo在这里:<a href="http://www.cnblogs.com/punkisnotdead/p/5158016.html" target="_blank" rel="noopener">http://www.cnblogs.com/punkisnotdead/p/5158016.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ikakaxi.github.io/2018/02/07/Android-进程间的通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的技术小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/Android-进程间的通信/" itemprop="url">Android 进程间的通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T22:12:09+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/Android-进程间的通信/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/Android-进程间的通信/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Android 世界里，默认的每个 APP 是一个单独的进程。其实这样的描述是不严格的，因为咱们要研究 Android 的进程间通信，肯定除了和其他的 APP 通信外，还可能和同一个 APP 下的其他进程通信。在 Java 里，每一个虚拟机是一个进程，Android 也是虚拟机的机制，你每启动一个 APP，默认会启动一个虚拟机上，一个虚拟机就是一个进程。在 APP 里，有还被运行创建另外的进程，在主进程结束后，这个进程还可以独立运行。</p>
<p>咱们这里不讨论怎么创建进程，咱们先讨论怎么让进程通信。</p>
<p>Android 里有四个基础组件，Activity，Service，Broastcast，Content Provider。</p>
<p>####Activity<br>Activity 跨进程通信其实咱们很经常用，但是却忽略了。咱们通过实例化一个 Intent，然后 startActivity ，是不是把一个意图，也就是 Intent 发送出去了？那么最终被 start 的 Activity 完全可能是在另外一个进程里的啊。比如你发送微博，你在你的 APP 里，通过 Intent 把数据发送给了微博客户端，微博客户端发完微博又回到了你的 APP，这个时候你需要 startActivityForResult 和 onActivityResult 就解决了你的进程和微博客户端进程的通信。</p>
<p>####Service<br>Service 是最复杂的。一般情况下，Service 和应用同在一个进程下，并且是主线程的。所以，一般 Service 也叫本地Service。既然有本地的，就有外地的，叫做远程 Service，remote service。如果一个 Service 是 remote service 的话，那么这个 Service 就会运行在一个独立的进程里。</p>
<p>既然跨进程了，就需要了解一个东西，叫 AIDL ， Android Interface Definition Language。它是一个定义语言，说白了，你可以理解它是一个中间的桥梁，进程A得知道进程B的接口（也就是方法），才可以调用，传递参数，获取返回值。</p>
<p>####Content Provider<br>Android 里，使用SQLite 数据库来存储数据，一般使用 SQLiteOpenHelper 创建的数据库是私有的，不希望它被其他的应用程序读取，甚至写入的，这个机制能保护你应用的数据安全。但是有时候你又需要对外提供数据，如果说电话本，短信等等，其他的应用都可以获取到的。Content Provider 其实也是对 SQLite 的另外一种封装而已，它提供了另外一种数据的访问方式。这个时候，你就需要理解什么是 URI ，统一资源路径。URI 就相当于官话，你懂我懂大家懂，而私有数据库就相当于方言，别人一般听不懂，hacker 例外。</p>
<p>Content Provider 可以在不同的应用之间共享数据。</p>
<p>####Broadcast<br>广播也很好理解了，系统广播一句“狼来啦”，然后大家都知道手机快没电了。A 广播一个消息（其实也是一个Intent），然后其他的应用程序可以接收到这个广播（当然得注册监听这个广播）。</p>
<p>广播虽然好用，但是有些局限性，通过 Intent 来携带数据，一般不允许携带复杂的数据，特别是一些大对象。另外，广播的频率也是一个问题，小喇叭嘴太欠的话，会遭人恨的。</p>
<p>####Bound Services<br>先来一段官方的解释：A bound service is the server in a client-server interface. A bound service allows components (such as activities) to bind to the service, send requests, receive responses, and even perform interprocess communication (IPC).</p>
<p>一个　Bound Service　可以和其他组件（当然也包括　Service　本身了）进行交互，也包括咱们要说的跨进程通信了。</p>
<p>一说到　Android　的跨进程通信，大家都想到了　AIDL，其实不仅是　AIDL，包括咱们上面说的，可以通过　Intent　的发送，来进行跨进程的通信，除此之外，用　bindService 的方式，也不仅仅是 AIDL。</p>
<p>从创建 Bound Service 开始。一般咱们使用 bindService 来获取一个 iBinder 对象，然后通过 iBinder 对象来与 Service 进行通信。</p>
<p>####Extending the Binder class<br>最一般的方式，就是继承于 Binder（Binder implements IBinder），然后写你想要的方法，在 Service 的 onBind 的方法里返回一个 Binder 对象。在其他组件里（比如 Activity）通过 bindService 来获取这个 Binder 对象，然后就可以和 Service 进行交互了。</p>
<p>这种方式适用于调用 Service 的组件和 Service 在同一个进程里。也就是没有跨进程啥事。</p>
<p>官方文档有这么一句话：The only reason you would not create your interface this way is because your service is used by other applications or across separate processes.也就是说，除非你真的需要跨进程，不然这个方式已经够用了，不要瞎搞跨进程。</p>
<p>####Using a Messenger<br>messenger 的翻译是报信者，送信者，信使。</p>
<p>这种方式，需要你在 Service 里实现一个 Handler 的子类，跟普通的 Handler 一样一样的。然后还需要一个 Messenger 对象，在 onBind 方法，通过 Messenger.getBinder() 获取一个 Binder。</p>
<p>(Messenger底层实现原理就是AIDL，它对AIDL做了一次封装，所以使用方法会比AIDL简单，由于它的效率比较低，一次只能处理一次请求，所以不存在线程同步的问题。)</p>
<p>Activity 通过 bindService 获取到 Binder 后，new Messenger(binder) ，Messenger 有个 send 方法，可以把一个 Message 对象发送出去，Service 的 Handler 就会收到这个 Message。跟咱们平常使用的 Handler 和 Message 的方式基本一样，只不过它是跨进程的。</p>
<p>不过到目前为止，这个通信是单向的，由 Activity 向 Service 发送，如果 Service 执行完某些操作后，需要给个响应呢，这个时候，需要 Activity 也实现一个 Messenger ，然后在 send() 的时候需要把这个 Messenger 也传过去。这样在 Service 执行完任务后，也会发送一个 Message 给 Activity。这样就实现了双方的通信。</p>
<p>这个消息队列是在一个线程里去管理的，所以你的 Service 是线程安全的，你不需要额外的设计来保证线程安全。</p>
<p><strong>使用这种方式需要注意, Messenger发送的Message里,传递的数据要保存在message的data里,例如message.getData().xxx,如果保存在obj里会报错</strong></p>
<p>This is the simplest way to perform interprocess communication(IPC), because the Messenger queues all requests into a single thread so that you don’t have to design your service to be thread-safe.</p>
<p>####AIDL<br>下面就开始 AIDL 了，这是大家很期待的，但是又是 Android 官方特别不推荐的方式。</p>
<p>AIDL (Android Interface Definition Language) performs all the work to decompose objects into primitives that the operating system can understand and marshall them across processes to perform IPC. The previous technique, using a Messenger, is actually based on AIDL as its underlying structure. As mentioned above, the Messenger creates a queue of all the client requests in a single thread, so the service receives requests one at a time. <strong>If, however, you want your service to handle multiple requests simultaneously, then you can use AIDL directly.</strong> In this case, your service must be capable of multi-threading and be built thread-safe.</p>
<p>看粗体的字。然后再看这段话下面还有一段话：</p>
<p><strong>Note:</strong> Most applications <strong>should not</strong> use AIDL to create a bound service, because it may require multithreading capabilities and can result in a more complicated implementation. As such, AIDL is not suitable for most applications and this document does not discuss how to use it for your service. If you’re certain that you need to use AIDL directly, see the AIDL document.</p>
<p>这段话的粗体不是我整的，是文档上的。意思就是说大部分应用不需要 AIDL 的。主要的问题出在，如果你使用 AIDL，你必须处理好多线程，并且保证线程安全。</p>
<p>这里不具体描述怎么使用 AIDL，大概就是需要写一个 aidl 文件，然后显示一个 Stub 的子类，其实 Stub 是 extends Binder，然后在 Service 的 onBind() 方法里返回一个 Stub 对象。其他组件还是通过 bindService 的方式获取这个 Binder，并且可以直接调用。</p>
<p>就是因为这里是直接调用，所以就调用者可以在任意线程里，任意时间调用，所以你需要处理好多线程，处理好线程安全。</p>
<p>以上就是 Android 里跟线程有关的内容。随时补充。</p>
<p>— EOF — </p>
<p>转载:<a href="http://www.binkery.com/archives/489.html" target="_blank" rel="noopener">http://www.binkery.com/archives/489.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ikakaxi.github.io/2018/02/07/Service的startService与bindService的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的技术小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/Service的startService与bindService的区别/" itemprop="url">Service的startService与bindService的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T22:11:45+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/Service的startService与bindService的区别/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/Service的startService与bindService的区别/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android执行Service有两种方法，一种是startService，一种是bindService。下面让我们一起来聊一聊这两种执行Service方法的区别。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545982-707a3bbe52ae3c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>#####1、生命周期上的区别</p>
<p>执行startService时，Service会经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。</p>
<p>执行bindService时，Service会经历onCreate-&gt;onBind。这个时候调用者和Service绑定在一起。调用者调用unbindService方法或者调用者Context不存在了（如Activity被finish了），Service就会调用onUnbind-&gt;onDestroy。这里所谓的绑定在一起就是说两者共存亡了。</p>
<p>多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。但是每次调用startService，onStartCommand方法都会被调用。Service的onStart方法在API 5时被废弃，替代它的是onStartCommand方法。</p>
<p>第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。</p>
<p>#####2、调用者如何获取绑定后的Service的方法</p>
<p>onBind回调方法将返回给客户端一个IBinder接口实例，IBinder允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。我们需要IBinder对象返回具体的Service对象才能操作，所以说具体的Service对象必须首先实现Binder对象。</p>
<p>#####3、既使用startService又使用bindService的情况</p>
<p>如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。</p>
<p>那么，什么情况下既使用startService，又使用bindService呢？</p>
<p>如果你只是想要启动一个后台服务长期进行某项任务，那么使用startService便可以了。如果你还想要与正在运行的Service取得联系，那么有两种方法：一种是使用broadcast，另一种是使用bindService。前者的缺点是如果交流较为频繁，容易造成性能上的问题，而后者则没有这些问题。因此，这种情况就需要startService和bindService一起使用了。</p>
<p>另外，如果你的服务只是公开一个远程接口，供连接上的客户端（Android的Service是C/S架构）远程调用执行方法，这个时候你可以不让服务一开始就运行，而只是bindService，这样在第一次bindService的时候才会创建服务的实例运行它，这会节约很多系统资源，特别是如果你的服务是远程服务，那么效果会越明显（当然在Servcie创建的时候会花去一定时间，这点需要注意）。    </p>
<p>#####4、本地服务与远程服务</p>
<p>本地服务依附在主进程上，在一定程度上节约了资源。本地服务因为是在同一进程，因此不需要IPC，也不需要AIDL。相应bindService会方便很多。缺点是主进程被kill后，服务变会终止。</p>
<p>远程服务是独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被kill的是偶，该服务依然在运行。缺点是该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。</p>
<p>对于startService来说，不管是本地服务还是远程服务，我们需要做的工作都一样简单。</p>
<p>5、代码实例</p>
<p>startService启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class LocalService1 extends Service &#123;</span><br><span class="line">    /**</span><br><span class="line">    * onBind 是 Service 的虚方法，因此我们不得不实现它。</span><br><span class="line">    * 返回 null，表示客服端不能建立到此服务的连接。</span><br><span class="line">    */</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onStartCommand(Intent intent, int startId, int flags) &#123;</span><br><span class="line">        super.onStartCommand(intent, startId, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bindService绑定服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class LocalService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    public SimpleBinder sBinder;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 在 Local Service 中我们直接继承 Binder 而不是 IBinder,因</span><br><span class="line">    为 Binder 实现了 IBinder 接口，这样我们可以** 少做很多工</span><br><span class="line">    作。</span><br><span class="line">    */</span><br><span class="line">    public class SimpleBinder extends Binder&#123;</span><br><span class="line">        /**</span><br><span class="line">        * 获取 Service 实例</span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">        public LocalService getService()&#123;</span><br><span class="line">            return LocalService.this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int add(int a, int b)&#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        // 创建 SimpleBinder</span><br><span class="line">        sBinder = new SimpleBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        // 返回 SimpleBinder 对象</span><br><span class="line">        return sBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码关键之处，在于 onBind(Intent) 这个方法 返回了一个实现了 IBinder 接口的对象，这个对象将用于绑定Service 的 Activity 与 Local Service 通信。</p>
<p>下面是 Activity 中的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Main extends Activity &#123;</span><br><span class="line">    private final static String TAG = &quot;SERVICE_TEST&quot;;</span><br><span class="line">    private ServiceConnection sc;</span><br><span class="line">    private boolean isBind;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">        sc = new ServiceConnection() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            @Override</span><br><span class="line">            public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">                LocalService.SimpleBinder sBinder = (LocalService.SimpleBinder)service;</span><br><span class="line">                Log.v(TAG, &quot;3 + 5 = &quot; + sBinder.add(3, 5));</span><br><span class="line">                Log.v(TAG, sBinder.getService().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        findViewById(R.id.btnBind).setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                bindService(new Intent(Main.this, LocalService.class), sc, Context.BIND_AUTO_CREATE);</span><br><span class="line">                isBind = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        findViewById(R.id.btnUnbind).setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if(isBind)&#123;</span><br><span class="line">                    unbindService(sc);</span><br><span class="line">                    isBind = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####6、在AndroidManifest.xml里Service元素常见选项<br>|属性|作用|<br>|——–|——–|<br>|android:name|服务类名|<br>|android:label|服务的名字，如果此项不设置，那么默认显示的服务名则为类名|<br>|android:icon|服务的图标|<br>|android:permission|申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务|<br>|android:process|表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字|<br>|android:enabled|表示是否能被系统实例化，为true表示可以，为false表示不可以，默认为true|<br>|android:exported|表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false|</p>
<p>转载:<a href="https://my.oschina.net/tingzi/blog/376545" target="_blank" rel="noopener">https://my.oschina.net/tingzi/blog/376545</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ikakaxi.github.io/2018/02/07/AndroidManifest-xml文件详解（service）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的技术小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/AndroidManifest-xml文件详解（service）/" itemprop="url"> AndroidManifest.xml文件详解（service）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T22:11:19+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/AndroidManifest-xml文件详解（service）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/AndroidManifest-xml文件详解（service）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>语法（SYNTAX）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">        android:enabled=[&quot;true&quot; | &quot;false&quot;]</span><br><span class="line">        android:exported[&quot;true&quot; | &quot;false&quot;]         </span><br><span class="line">        android:icon=&quot;drawable resource&quot;</span><br><span class="line">        android:label=&quot;string resource&quot;</span><br><span class="line">        android:name=&quot;string&quot; </span><br><span class="line">        android:permission=&quot;string&quot;         </span><br><span class="line">        android:process=&quot;string&quot;&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>被包含于（CONTAINED IN）：</strong></p>
<p><application><br><strong>可能包含的元素（CAN CONTAIN）：</strong></application></p>
<p><intent-filter></intent-filter></p>
<meta-data>

<p><strong>说明（DESCRIPTION）：</strong><br>这个元素用于声明一个服务（Service类的子类）作为应用程序的组件之一。跟Activity不一样，服务没有可见的用户界面。它们被用于实现长时的后台操作，或提供能够被其他应用程序调用的通信API。<br>所有的服务都必须用清单文件中的<service>元素来代表。任何没有在清单中声明的服务都不能被系统看到，也不会被运行。</service></p>
<p><strong>属性（ATTRIBUTES）：</strong></p>
<p><strong>android:enabled</strong><br>这个属性用于指示该服务是否能够被实例化。如果设置为true，则能够被实例化，否则不能被实例化。默认值是true。</p>
<p><application>元素有它自己的enabled属性，它的这个属性适用于应用中所有的组件，包括service组件。对于被启用的服务，<application>和<service>元素的enabled属性都必须是true（默认值都是true）。如果有一个元素的enabled属性被设置为false，该服务就会被禁用，而不能被实例化。</service></application></application></p>
<p><strong>android:exported</strong><br>这个属性用于指示该服务是否能够被其他应用程序组件调用或跟它交互。如果设置为true，则能够被调用或交互，否则不能。设置为false时，只有同一个应用程序的组件或带有相同用户ID的应用程序才能启动或绑定该服务。<br>它的默认值依赖与该服务所包含的过滤器。没有过滤器则意味着该服务只能通过指定明确的类名来调用，这样就是说该服务只能在应用程序的内部使用（因为其他外部使用者不会知道该服务的类名），因此这种情况下，这个属性的默认值是false。另一方面，如果至少包含了一个过滤器，则意味着该服务可以给外部的其他应用提供服务，因此默认值是true。<br>这个属性不是限制把服务暴露给其他应用程序的唯一方法。还可以使用权限来限制能够跟该服务交互的外部实体。</p>
<p><strong>android:icon</strong><br>这个属性定义了一个代表服务的图标，它必须要引用一个包含图片定义的可绘制资源。如果这个属性没有设置，则会使用<application>元素的icon属性所设定的图标来代替。<br>无论是<application>元素设置的图标，还是<service>元素所设置的图标，它们都是该服务所有的Intent过滤器的默认图标。</service></application></application></p>
<p><strong>android:label</strong><br>这个属性用于设定一个要显示给用户的服务的名称。如果没有设置这个属性，则会使用<application>元素的label属性值来代替。<br>无论是<service>设定的标签，还是<application>元素设定的标签，它们都是该服务所有的Intent过滤器的默认标签。<br>这个标签应用引用一个字符串资源，以便它能够像用户界面中的字符串一样能够被本地化。但是，为了开发应用程序方便，也可以使用原生字符串来设置这个属性。</application></service></application></p>
<p><strong>android:name</strong><br>这个属性用于指定实现该服务的Service子类的类名。它应该是完整的Java类名（如：com.example.project.RoomService）。但是，也可以使用简写（如：.RoomService），系统会把<manifest>元素中package属性所设定的值添加到简写名称的前面。<br>一旦发布了应用程序，就不应该改变这个名称（除非android:exported=”false”）。<br>这个属性没有默认值，名称必须要指定。</manifest></p>
<p><strong>android:permission</strong><br>这个属性定义了要启动或绑定服务的实体必须要有的权限。如果调用者的startService()、bindService()和stopService()方法没有被授予这个权限，那么这些方法就不会工作，并且Intent对象也不会发送给改服务。<br>如果这个属性没被设置，那么通过<appliction>元素的permission属性所设定的权限就会适用于该服务。如果<application>元素也没有设置权限，则该服务不受权限保护。</application></appliction></p>
<p><strong>android:process</strong><br>这个属性用于设定服务所运行的进程名称。通常，应用程序的所有组件都运行在给应用程序创建的进程中，进程名与应用程序的包名相同。<application>元素的process属性能够给应用程序的所有组件设置一个不同的默认名称。但是每个组件自己的process属性都能够覆盖这个默认值，这样允许把应用程序分离到不同的多个进程中。<br>如果这个属性值用“:”开头，则在需要的时候系统会创建一个新的，应用程序私有的进程，并且该服务也会运行在这个进程中。如果这个属性值用小写字母开头，那该服务就会运行在以这个属性值命名的全局进程中，它提供了使其工作的权限。这样就允许不同的应用程序组件来共享这个进程，从而降低资源的使用。</application></p>
<p><strong>被引入的版本（INTRODUCED IN）：</strong><br>API Level 1</p>
</meta-data>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ikakaxi.github.io/2018/02/07/使用adb-dumpsys-命令查看app占用内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="superman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的技术小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/使用adb-dumpsys-命令查看app占用内存/" itemprop="url">使用adb dumpsys 命令查看app占用内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T22:10:49+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/使用adb-dumpsys-命令查看app占用内存/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/使用adb-dumpsys-命令查看app占用内存/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>adb是一个非常强大的工具，使用adb查看应用程序内存使用情况可按如下格式在命令行里查看内存使用情况：<br>adb shell dumpsys meminfo <package_name><br>其中，package_name 也可以换成程序的pid，pid可以通过 adb shell top | grep app_name 来查找，下图是某个程序的内存使用情况：<br><img src="http://upload-images.jianshu.io/upload_images/545982-75efbde6fda86be3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">重点关注如下几个字段：<br>（1） Native/Dalvik 的 Heap 信息具体在上面的第一行和第二行，它分别给出的是JNI层和Java层的内存分配情况，如果发现这个值一直增长，则代表程序可能出现了内存泄漏。<br>（2） Total 的 PSS 信息这个值就是你的应用真正占据的内存大小，通过这个信息，你可以轻松判别手机中哪些程序占内存比较大了。</package_name></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">superman</p>
              <p class="site-description motion-element" itemprop="description">用来记录一些技术文章</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">104</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">superman</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p>
  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://liuhc.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
